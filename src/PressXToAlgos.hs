module PressXToAlgos where

import Data.List (nub)
import Data.Map (Map, (!))
import qualified Data.Map as Map

dijkstra :: (Ord a, Ord c) => (c -> a -> [(c, a)]) -> c -> a -> (a -> Bool) -> [[(c, a)]]
dijkstra step zero start done = shortestPaths
  where
    prevs = Map.singleton start []
    queue = Map.fromListWith (++) [(cost, [(cost, start, curr)]) | (cost, curr) <- step zero start]
    backPointers = forward done step prevs queue
    shortestPaths = filter done (Map.keys backPointers) >>= backward backPointers zero start

    -- Explore the search space till an objective is met and return a map of backpointers from the objective
    forward :: (Ord a, Ord c) => (a -> Bool) -> (c -> a -> [(c, a)]) -> Map a [(c, a, a)] -> Map c [(c, a, a)] -> Map a [(c, a, a)]
    forward done step prevs queue = case Map.minViewWithKey queue of
      Just ((cost, branches), queue) | not (any (any (\(_, _, n) -> done n)) prevs) -> forward done step prevs' queue'
        where
          updatePrevs branch@(cost, prev, curr) = Map.insertWith (++) curr [branch]
          updateQueue branch@(cost, curr, next) = Map.insertWith (++) cost [branch]
          prevs' = foldr updatePrevs prevs branches -- Update backpointers for all branches with the current cost
          queue' = foldr updateQueue queue branches' -- Enqueue new branches from all previously unvisited nodes
          branches' = do
            i <- nub [node | (_, _, node) <- branches, Map.notMember node prevs]
            (c, j) <- step cost i
            return (c, i, j)
      _ -> prevs

    -- Traverse backpointers generated by the forward pass to generate all shortest paths from target to node
    backward :: (Ord a, Ord c) => Map a [(c, a, a)] -> c -> a -> a -> [[(c, a)]]
    backward links zero target node = reverse <$> go node
      where
        go node
          | node == target = [[(zero, node)]]
          | Map.notMember node links = []
          | otherwise = ((minCost, node) :) <$> concatMap go minCostPrevs
          where
            branches = links ! node
            minCost = minimum [c | (c, _, _) <- branches]
            minCostPrevs = [n | (c, n, _) <- branches, c == minCost]
