module PressXToAlgos where

import Data.List (nub)
import Data.Map (Map, (!))
import qualified Data.Map as Map

type Branch a = (Int, a, a) -- (c, i, j): c = cost(i -> j)

dijkstra :: (Ord a) => (a -> Bool) -> (a -> [(Int, a)]) -> a -> [[(Int, a)]]
dijkstra done next start = shortestPaths
  where
    prevs = Map.singleton start []
    queue = Map.fromListWith (++) [(cost, [(cost, start, curr)]) | (cost, curr) <- next start]
    backPointers = forward done next prevs queue
    shortestPaths = filter done (Map.keys backPointers) >>= backward backPointers start

    -- Explore the search space till an objective is met and return a map of backpointers from the objective
    forward :: (Ord a) => (a -> Bool) -> (a -> [(Int, a)]) -> Map a [Branch a] -> Map Int [Branch a] -> Map a [Branch a]
    forward done next prevs queue = case Map.minViewWithKey queue of
      Just ((cost, branches), queue) | not (any (any (\(_, _, n) -> done n)) prevs) -> forward done next prevs' queue'
        where
          updatePrevs branch@(cost, prev, curr) = Map.insertWith (++) curr [branch]
          updateQueue branch@(cost, curr, next) = Map.insertWith (++) cost [branch]
          prevs' = foldr updatePrevs prevs branches -- Update backpointers for all branches with the current cost
          queue' = foldr updateQueue queue branches' -- Enqueue new branches from all previously unvisited nodes
          branches' = do
            i <- nub [node | (_, _, node) <- branches, Map.notMember node prevs]
            (incr, j) <- next i
            return (cost + incr, i, j)
      _ -> prevs

    -- Traverse backpointers generated by the forward pass to generate all shortest paths from target to node
    backward :: (Ord a) => Map a [Branch a] -> a -> a -> [[(Int, a)]]
    backward links target node = reverse <$> go node
      where
        go node
          | node == target = [[(0, node)]]
          | Map.notMember node links = []
          | otherwise = ((minCost, node) :) <$> concatMap go minCostPrevs
          where
            branches = links ! node
            minCost = minimum [c | (c, _, _) <- branches]
            minCostPrevs = [n | (c, n, _) <- branches, c == minCost]
